<!DOCTYPE html>
<html lang="en">
    <head>
        
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta name="description" content="Ed On Code is a blog about software development and related topics.">
        

        <title>Ed On Code</title>

        
            <link rel="stylesheet" href="https://edoncode.dev/theme.css">
        
        
    </head>
    <body>
        <div class="content">
        
        
            <header>
                <div class="header-left">
                    <a href="https://edoncode.dev" class="logo">Ed On Code</a>
                </div>
                <div class="header-right">
                    <nav itemscope itemtype="http://schema.org/SiteNavigationElement">
                      <ul>
                        
                        
                            
                            <li class="nav">
                                <a itemprop="url" href="https://edoncode.dev/Tech/">
                                    <span itemprop="name">Tech</span>
                                </a>
                            </li>
                        
                            
                            <li class="nav">
                                <a itemprop="url" href="https://edoncode.dev/Golang/">
                                    <span itemprop="name">Golang</span>
                                </a>
                            </li>
                        
                            
                            <li class="nav">
                                <a itemprop="url" href="https://edoncode.dev/Adventures/">
                                    <span itemprop="name">Adventures</span>
                                </a>
                            </li>
                        
                            
                            <li class="nav">
                                <a itemprop="url" href="https://edoncode.dev/Thoughts/">
                                    <span itemprop="name">Thoughts</span>
                                </a>
                            </li>
                        
                        
                        <li class="nav">
                            <a itemprop="url" href="https://github.com/eduardonunesp">
                                <img class="icon" src="https://edoncode.dev/icons/github.svg" alt="Github">
                            </a>
                        </li>
                        
                        
                      </ul>
                    </nav>
                </div>
            </header>
        
        
        <main>
            
<article itemscope itemtype="http://schema.org/BlogPosting">
    <div itemprop="headline">
        <h1>Understanding the Two Sum Problem in Go</h1>
        <div class="border"></div>
        <time datetime="2024-05-13" class="date" itemprop="datePublished">
            13 May 2024
        </time>
    </div>
    <div itemprop="articleBody">
        <h1 id="Understanding_the_Two_Sum_Problem_in_Go:_Optimized_and_Brute_Force_Solutions">Understanding the Two Sum Problem in Go: Optimized and Brute Force Solutions</h1>
<p>The <strong>Two Sum</strong> problem is a staple in algorithmic challenges, often used to assess a programmer's problem-solving skills and understanding of data structures. This article explores two Go (Golang) implementations of the Two Sum problem: an optimized approach using a hash map and a straightforward brute-force method. We'll delve into the problem statement, dissect both solutions, and analyze their time and space complexities.</p>
<hr />
<h2 id="Table_of_Contents">Table of Contents</h2>
<ol>
<li><a href="https://edoncode.dev/Golang/understanding-two-sum-problem-in-go/#problem-statement">Problem Statement</a></li>
<li><a href="https://edoncode.dev/Golang/understanding-two-sum-problem-in-go/#solution-1-optimized-approach-using-a-hash-map">Solution 1: Optimized Approach Using a Hash Map</a>
<ul>
<li><a href="https://edoncode.dev/Golang/understanding-two-sum-problem-in-go/#solution-1-code-overview">Solution 1 Code Overview</a></li>
<li><a href="https://edoncode.dev/Golang/understanding-two-sum-problem-in-go/#solution-1-how-it-works">Solution 1 How It Works</a></li>
<li><a href="https://edoncode.dev/Golang/understanding-two-sum-problem-in-go/#solution-1-example-walkthrough">Solution 1 Example Walkthrough</a></li>
<li><a href="https://edoncode.dev/Golang/understanding-two-sum-problem-in-go/#solution-1-time-and-space-complexity">Solution 1 Time and Space Complexity</a></li>
</ul>
</li>
<li><a href="https://edoncode.dev/Golang/understanding-two-sum-problem-in-go/#solution-2-brute-force-approach-using-nested-loops">Solution 2: Brute Force Approach Using Nested Loops</a>
<ul>
<li><a href="https://edoncode.dev/Golang/understanding-two-sum-problem-in-go/#solution-2-code-overview">Solution 2 Code Overview</a></li>
<li><a href="https://edoncode.dev/Golang/understanding-two-sum-problem-in-go/#solution-2-how-it-works">Solution 2 How It Works</a></li>
<li><a href="https://edoncode.dev/Golang/understanding-two-sum-problem-in-go/#solution-2-example-walkthrough">Solution 2 Example Walkthrough</a></li>
<li><a href="https://edoncode.dev/Golang/understanding-two-sum-problem-in-go/#solution-2-time-and-space-complexity">Solution 2 Time and Space Complexity</a></li>
</ul>
</li>
<li><a href="https://edoncode.dev/Golang/understanding-two-sum-problem-in-go/#comparing-the-two-approaches">Comparing the Two Approaches</a></li>
<li><a href="https://edoncode.dev/Golang/understanding-two-sum-problem-in-go/#conclusion">Conclusion</a></li>
</ol>
<hr />
<h2 id="Problem_Statement">Problem Statement</h2>
<p><strong>Given</strong>:</p>
<ul>
<li>An array of integers <code>nums</code>.</li>
<li>An integer <code>target</code>.</li>
</ul>
<p><strong>Objective</strong>:
Return the indices of the two numbers in <code>nums</code> such that they add up to <code>target</code>.</p>
<p><strong>Constraints</strong>:</p>
<ul>
<li>Each input will have exactly one solution.</li>
<li>You may not use the same element twice.</li>
<li>The answer can be returned in any order.</li>
</ul>
<h3 id="Examples">Examples</h3>
<ol>
<li>
<p><strong>Example 1</strong>:</p>
<ul>
<li><strong>Input</strong>: <code>nums = [2,7,11,15]</code>, <code>target = 9</code></li>
<li><strong>Output</strong>: <code>[0,1]</code></li>
<li><strong>Explanation</strong>: Because <code>nums[0] + nums[1] == 9</code>, we return <code>[0, 1]</code>.</li>
</ul>
</li>
<li>
<p><strong>Example 2</strong>:</p>
<ul>
<li><strong>Input</strong>: <code>nums = [3,2,3]</code>, <code>target = 6</code></li>
<li><strong>Output</strong>: <code>[0,2]</code></li>
</ul>
</li>
<li>
<p><strong>Example 3</strong>:</p>
<ul>
<li><strong>Input</strong>: <code>nums = [3,3]</code>, <code>target = 6</code></li>
<li><strong>Output</strong>: <code>[0,1]</code></li>
</ul>
</li>
</ol>
<hr />
<h2 id="Solution_1:_Optimized_Approach_Using_a_Hash_Map">Solution 1: Optimized Approach Using a Hash Map</h2>
<h3 id="Solution_1_Code_Overview">Solution 1 Code Overview</h3>
<pre data-lang="go" style="background-color:#2b303b;color:#c0c5ce;" class="language-go "><code class="language-go" data-lang="go"><span style="color:#b48ead;">func </span><span style="color:#8fa1b3;">twoSum</span><span>(</span><span style="color:#bf616a;">nums </span><span>[]</span><span style="color:#b48ead;">int</span><span>, </span><span style="color:#bf616a;">target </span><span style="color:#b48ead;">int</span><span>) []</span><span style="color:#b48ead;">int </span><span>{
</span><span>    </span><span style="color:#65737e;">// Create a map to store the difference and its index
</span><span>    </span><span style="color:#bf616a;">resultMap </span><span>:= </span><span style="color:#96b5b4;">make</span><span>(</span><span style="color:#b48ead;">map</span><span>[</span><span style="color:#b48ead;">int</span><span>]</span><span style="color:#b48ead;">int</span><span>)
</span><span>    </span><span style="color:#b48ead;">for </span><span style="color:#bf616a;">idx</span><span>, </span><span style="color:#bf616a;">num </span><span>:= </span><span style="color:#b48ead;">range </span><span style="color:#bf616a;">nums </span><span>{
</span><span>        </span><span style="color:#65737e;">// Calculate the desired complement
</span><span>        </span><span style="color:#bf616a;">desired </span><span>:= </span><span style="color:#bf616a;">target </span><span>- </span><span style="color:#bf616a;">num
</span><span>        </span><span style="color:#65737e;">// Check if the complement exists in the map
</span><span>        </span><span style="color:#b48ead;">if </span><span style="color:#bf616a;">n</span><span>, </span><span style="color:#bf616a;">ok </span><span>:= </span><span style="color:#bf616a;">resultMap</span><span>[</span><span style="color:#bf616a;">desired</span><span>]; </span><span style="color:#bf616a;">ok </span><span>{
</span><span>            </span><span style="color:#65737e;">// If found, return the pair of indices
</span><span>            </span><span style="color:#b48ead;">return </span><span>[]</span><span style="color:#b48ead;">int</span><span>{</span><span style="color:#bf616a;">n</span><span>, </span><span style="color:#bf616a;">idx</span><span>}
</span><span>        }
</span><span>        </span><span style="color:#65737e;">// Store the current number and its index in the map
</span><span>        </span><span style="color:#bf616a;">resultMap</span><span>[</span><span style="color:#bf616a;">num</span><span>] = </span><span style="color:#bf616a;">idx
</span><span>    }
</span><span>    </span><span style="color:#b48ead;">return </span><span>[]</span><span style="color:#b48ead;">int</span><span>{}
</span><span>}
</span></code></pre>
<h3 id="Solution_1_How_It_Works">Solution 1 How It Works</h3>
<ol>
<li>
<p><strong>Initialization</strong>:</p>
<ul>
<li>A hash map <code>resultMap</code> is created to store numbers as keys and their corresponding indices as values.</li>
</ul>
</li>
<li>
<p><strong>Iteration</strong>:</p>
<ul>
<li>Iterate through each element <code>num</code> in the <code>nums</code> array using its index <code>idx</code>.</li>
</ul>
</li>
<li>
<p><strong>Complement Calculation</strong>:</p>
<ul>
<li>For each <code>num</code>, compute the <code>desired</code> complement that would add up to the <code>target</code> (<code>desired = target - num</code>).</li>
</ul>
</li>
<li>
<p><strong>Hash Map Lookup</strong>:</p>
<ul>
<li>Check if the <code>desired</code> complement exists in <code>resultMap</code>.</li>
<li>If it does, it means we've previously encountered the number that pairs with the current <code>num</code> to reach the <code>target</code>. Return the indices of these two numbers.</li>
</ul>
</li>
<li>
<p><strong>Map Population</strong>:</p>
<ul>
<li>If the <code>desired</code> complement is not found, store the current <code>num</code> and its index in <code>resultMap</code> for future reference.</li>
</ul>
</li>
<li>
<p><strong>Return Statement</strong>:</p>
<ul>
<li>If no solution is found during iteration (which shouldn't happen as per the problem constraints), return an empty slice.</li>
</ul>
</li>
</ol>
<h3 id="Solution_1_Example_Walkthrough">Solution 1 Example Walkthrough</h3>
<p>Let's consider <strong>Example 1</strong>:</p>
<ul>
<li><strong>Input</strong>: <code>nums = [2,7,11,15]</code>, <code>target = 9</code></li>
<li><strong>Process</strong>:
<ol>
<li>
<p><strong>First Iteration (<code>idx=0</code>, <code>num=2</code>)</strong>:</p>
<ul>
<li><code>desired = 9 - 2 = 7</code></li>
<li><code>7</code> is not in <code>resultMap</code>.</li>
<li>Store <code>2</code> with index <code>0</code> in <code>resultMap</code>: <code>{2: 0}</code>.</li>
</ul>
</li>
<li>
<p><strong>Second Iteration (<code>idx=1</code>, <code>num=7</code>)</strong>:</p>
<ul>
<li><code>desired = 9 - 7 = 2</code></li>
<li><code>2</code> is in <code>resultMap</code> with index <code>0</code>.</li>
<li>Return <code>[0, 1]</code>.</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="Solution_1_Time_and_Space_Complexity">Solution 1 Time and Space Complexity</h3>
<ul>
<li>
<p><strong>Time Complexity</strong>: <strong>O(N)</strong></p>
<ul>
<li>The algorithm traverses the list containing <code>N</code> elements only once. Each look-up in the hash map costs <strong>O(1)</strong> time on average.</li>
</ul>
</li>
<li>
<p><strong>Space Complexity</strong>: <strong>O(N)</strong></p>
<ul>
<li>In the worst case, we store all <code>N</code> elements in the hash map.</li>
</ul>
</li>
</ul>
<hr />
<h2 id="Solution_2:_Brute_Force_Approach_Using_Nested_Loops">Solution 2: Brute Force Approach Using Nested Loops</h2>
<h3 id="Solution_2_Code_Overview">Solution 2 Code Overview</h3>
<pre data-lang="go" style="background-color:#2b303b;color:#c0c5ce;" class="language-go "><code class="language-go" data-lang="go"><span style="color:#b48ead;">func </span><span style="color:#8fa1b3;">twoSumsBruteForce</span><span>(</span><span style="color:#bf616a;">nums </span><span>[]</span><span style="color:#b48ead;">int</span><span>, </span><span style="color:#bf616a;">target </span><span style="color:#b48ead;">int</span><span>) []</span><span style="color:#b48ead;">int </span><span>{
</span><span>    </span><span style="color:#65737e;">// Iterate through each element for the first number
</span><span>    </span><span style="color:#b48ead;">for </span><span style="color:#bf616a;">idx1 </span><span>:= </span><span style="color:#d08770;">0</span><span>; </span><span style="color:#bf616a;">idx1 </span><span>&lt; </span><span style="color:#96b5b4;">len</span><span>(</span><span style="color:#bf616a;">nums</span><span>); </span><span style="color:#bf616a;">idx1</span><span>++ {
</span><span>        </span><span style="color:#65737e;">// Iterate through the remaining elements for the second number
</span><span>        </span><span style="color:#b48ead;">for </span><span style="color:#bf616a;">idx2 </span><span>:= </span><span style="color:#bf616a;">idx1 </span><span>+ </span><span style="color:#d08770;">1</span><span>; </span><span style="color:#bf616a;">idx2 </span><span>&lt; </span><span style="color:#96b5b4;">len</span><span>(</span><span style="color:#bf616a;">nums</span><span>); </span><span style="color:#bf616a;">idx2</span><span>++ {
</span><span>            </span><span style="color:#65737e;">// Check if the pair sums up to the target
</span><span>            </span><span style="color:#b48ead;">if </span><span style="color:#bf616a;">nums</span><span>[</span><span style="color:#bf616a;">idx1</span><span>]+</span><span style="color:#bf616a;">nums</span><span>[</span><span style="color:#bf616a;">idx2</span><span>] == </span><span style="color:#bf616a;">target </span><span>{
</span><span>                </span><span style="color:#b48ead;">return </span><span>[]</span><span style="color:#b48ead;">int</span><span>{</span><span style="color:#bf616a;">idx1</span><span>, </span><span style="color:#bf616a;">idx2</span><span>}
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>    </span><span style="color:#b48ead;">return </span><span>[]</span><span style="color:#b48ead;">int</span><span>{}
</span><span>}
</span></code></pre>
<h3 id="Solution_2_How_It_Works">Solution 2 How It Works</h3>
<ol>
<li>
<p><strong>Outer Loop</strong>:</p>
<ul>
<li>Iterate through each element <code>nums[idx1]</code> in the array.</li>
</ul>
</li>
<li>
<p><strong>Inner Loop</strong>:</p>
<ul>
<li>For each <code>nums[idx1]</code>, iterate through the subsequent elements <code>nums[idx2]</code> to find a pair that sums to the <code>target</code>.</li>
</ul>
</li>
<li>
<p><strong>Pair Check</strong>:</p>
<ul>
<li>If a pair <code>nums[idx1] + nums[idx2]</code> equals the <code>target</code>, return their indices <code>[idx1, idx2]</code>.</li>
</ul>
</li>
<li>
<p><strong>Return Statement</strong>:</p>
<ul>
<li>If no such pair is found after exhausting all possibilities (which, according to the problem constraints, should not occur), return an empty slice.</li>
</ul>
</li>
</ol>
<h3 id="Solution_2_Example_Walkthrough">Solution 2 Example Walkthrough</h3>
<p>Using <strong>Example 1</strong>:</p>
<ul>
<li><strong>Input</strong>: <code>nums = [2,7,11,15]</code>, <code>target = 9</code></li>
<li><strong>Process</strong>:
<ol>
<li><strong>First Iteration (<code>idx1=0</code>, <code>num=2</code>)</strong>:
<ul>
<li>Compare with <code>idx2=1</code> (<code>num=7</code>): <code>2 + 7 = 9</code> → Match found.</li>
<li>Return <code>[0, 1]</code>.</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="Solution_2_Time_and_Space_Complexity">Solution 2 Time and Space Complexity</h3>
<ul>
<li>
<p><strong>Time Complexity</strong>: <strong>O(N²)</strong></p>
<ul>
<li>Two nested loops each potentially iterate through all <code>N</code> elements, leading to a quadratic time complexity.</li>
</ul>
</li>
<li>
<p><strong>Space Complexity</strong>: <strong>O(1)</strong></p>
<ul>
<li>The algorithm uses a constant amount of extra space.</li>
</ul>
</li>
</ul>
<hr />
<h2 id="Comparing_the_Two_Approaches">Comparing the Two Approaches</h2>
<table><thead><tr><th>Aspect</th><th>Optimized (Hash Map)</th><th>Brute Force (Nested Loops)</th></tr></thead><tbody>
<tr><td><strong>Time Complexity</strong></td><td>O(N)</td><td>O(N²)</td></tr>
<tr><td><strong>Space Complexity</strong></td><td>O(N)</td><td>O(1)</td></tr>
<tr><td><strong>Ease of Implementation</strong></td><td>Moderate</td><td>Simple</td></tr>
<tr><td><strong>Performance</strong></td><td>Significantly faster for large inputs</td><td>Slower, especially with large datasets</td></tr>
</tbody></table>
<p><strong>Summary</strong>:</p>
<ul>
<li>The <strong>optimized approach</strong> using a hash map offers a linear time solution, making it highly efficient for large datasets. However, it requires additional space proportional to the input size.</li>
<li>The <strong>brute-force method</strong> is straightforward and easy to implement but suffers from poor performance with increasing input sizes due to its quadratic time complexity.</li>
</ul>
<hr />
<h2 id="Conclusion">Conclusion</h2>
<p>The Two Sum problem is an excellent exercise to understand the balance between time and space complexities in algorithm design. By leveraging data structures like hash maps, we can optimize solutions to run efficiently even with large inputs. Conversely, grasping brute-force methods provides foundational knowledge that helps recognize when and how optimizations can be applied.</p>
<p>In Go, both methods are elegantly implemented, showcasing the language's strengths in handling maps and control structures. Whether you're preparing for coding interviews or enhancing your algorithmic skills, mastering both approaches to the Two Sum problem is invaluable.</p>
<hr />
<p><strong>Happy Coding!</strong></p>

    </div>
</article>

        </main>
        
        <footer>
            
            <div class="border"></div>
            <div class="footer">
                <small class="footer-left">
                    Copyright &copy; Eduardo Pereira
                </small>
                <small class="footer-right">
                    Powered by <a href="https://www.getzola.org">Zola</a> | Theme <a href="https://github.com/barlog-m/oceanic-zen">Oceanic Zen</a>
                </small>
            </div>
        
        </footer>
    
        </div>
    </body>
</html>
